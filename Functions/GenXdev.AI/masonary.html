<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Image Gallery - Masonry Layout</title>
        <style>
        * {
            box-sizing: border-box;
        }

        #bg {
            background-color: #333333;
            width: 100%;
            min-height: 100vh;
            position: relative;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #333333;
            color: #333;
        }

        html {
            background-color: #333333;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: white;
            margin-top: 2em;
            font-weight: 300;
        }

        .header p {
            color: #7f8c8d;
            margin: 0;
        }

        .gallery-container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .masonry {
            column-count: 1;
            column-gap: 20px;
            column-fill: balance;
        }

        @media (min-width: 768px) {
            .masonry { column-count: 2; }
        }

        @media (min-width: 1024px) {
            .masonry { column-count: 3; }
        }

        @media (min-width: 1400px) {
            .masonry { column-count: 4; }
        }

        .gallery-item {
            break-inside: avoid;
            margin-bottom: 20px;
            background: white;
            border-radius: 8px;
            border: 1px solid black;
            overflow: hidden;
            transition: border-color 0.2s ease, background-color 0.2s ease;
            position: relative;
        }

        .gallery-item:hover {
            background: #fafafa;
            border-color: #666;
        }

        .image-container {
            position: relative;
            overflow: hidden;
        }

        .gallery-item img {
            width: 100%;
            height: auto;
            display: block;
            border-bottom: 1px solid black;
            transition: filter 0.2s ease;
        }

        .gallery-item:hover img {
            filter: brightness(1.05);
        }

        .face-overlay {
            position: absolute;
            border: 2px solid #000000;
            background-color: rgba(255, 255, 255, 0.5);
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .gallery-item:hover .face-overlay {
            opacity: 1;
        }

        .face-label {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            text-align: center;
            line-height: 1.3;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            white-space: nowrap;
        }

        .object-label {
            position: absolute;
            top: -2px;
            left: -2px;
            background-color: rgba(255, 107, 107, 0.9);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
            line-height: 1.2;
            box-shadow: 0 1px 4px rgba(0,0,0,0.3);
            white-space: nowrap;
        }

        .object-overlay {
            position: absolute;
            border: 2px solid #ff6b6b;
            background-color: rgba(255, 107, 107, 0.2);
            pointer-events: none;
            box-sizing: border-box;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .gallery-item:hover .object-overlay {
            opacity: 1;
        }

        .content {
            padding: 15px;
        }

        .description {
            margin-bottom: 12px;
        }

        .short-description {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 6px;
            font-size: 14px;
        }

        .long-description {
            color: #5d6d7e;
            font-size: 13px;
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .metadata {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 12px;
        }

        .metadata-item {
            background-color: #ecf0f1;
            color: #34495e;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
        }

        .metadata-item.people {
            background-color: #e8f5e8;
            color: #27ae60;
        }

        .metadata-item.faces {
            background-color: #fff3cd;
            color: #856404;
        }

        .keywords {
            margin-bottom: 10px;
        }

        .keywords-label {
            font-size: 11px;
            color: #7f8c8d;
            margin-bottom: 4px;
            font-weight: 600;
        }

        .keyword-tag {
            display: inline-block;
            background-color: #f8f9fa;
            color: #495057;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            margin: 2px 2px 2px 0;
            border: 1px solid #dee2e6;
        }

        .recognized-faces {
            margin-bottom: 10px;
        }

        .faces-label {
            font-size: 11px;
            color: #7f8c8d;
            margin-bottom: 4px;
            font-weight: 600;
        }

        .face-name-tag {
            background-color: #27ae60;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 11px;
            margin: 2px 4px 2px 0;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: inline-block;
        }

        .face-name-tag:hover, .face-name-tag:focus {
            background-color: #219a52;
            outline: none;
        }

        .detected-objects {
            margin-bottom: 10px;
        }

        .objects-label {
            font-size: 11px;
            color: #7f8c8d;
            margin-bottom: 4px;
            font-weight: 600;
        }

        .object-name-tag {
            display: inline-block;
            background-color: #f1c40f;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 11px;
            margin: 2px 2px 2px 0;
            border: none;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }        .object-name-tag:hover {
            background-color: #f39c12;
        }

        .scene-classification {
            margin-bottom: 10px;
        }

        .scene-label {
            font-size: 11px;
            color: #7f8c8d;
            margin-bottom: 4px;
            font-weight: 600;
        }

        .scene-name-tag {
            display: inline-block;
            background-color: #8e44ad;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 11px;
            margin: 2px 2px 2px 0;
            border: none;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .scene-name-tag:hover {
            background-color: #7d3c98;
        }.metadata-item.objects {
            background-color: #fff3cd;
            color: #856404;
        }

        .metadata-item.scene {
            background-color: #e7f3ff;
            color: #2c5aa0;
        }

        .actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .copy-path-btn {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            font-weight: 500;
        }

        .copy-path-btn:hover {
            background-color: #2980b9;
        }

        .copy-path-btn:active {
            transform: scale(0.98);
        }

        .view-original {
            background-color: #3498db;
            color: white;
            text-decoration: none;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: inline-block;
        }

        .view-original:hover {
            background-color: #2980b9;
            color: white;
            text-decoration: none;
        }

        .view-original:active {
            transform: scale(0.98);
        }

        .edit-btn {
            background-color: #27ae60;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            font-weight: 500;
        }

        .edit-btn:hover {
            background-color: #219a52;
        }

        .edit-btn:active {
            transform: scale(0.98);
        }

        .delete-btn {
            background-color: #e74c3c;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            font-weight: 500;
        }

        .delete-btn:hover {
            background-color: #c0392b;
        }

        .delete-btn:active {
            transform: scale(0.98);
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
        }

        .no-images {
            text-align: center;
            padding: 60px 20px;
            color: #7f8c8d;
        }

        .no-images h3 {
            margin-bottom: 10px;
            color: #95a5a6;
        }

        .sentinel {
            height: 100px;
            width: 100%;
            visibility: hidden;
        }

        @media print {
            /* Prevent page breaks within key elements */
            html, body, #bg, .gallery-container, .masonry {
                height: auto !important;
                min-height: unset !important;
                overflow: visible !important;
                page-break-before: avoid;
                page-break-after: avoid;
                page-break-inside: avoid;
                margin: 0;
                padding: 0;
            }

            /* Ensure single-column layout for print */
            .masonry {
                column-count: 1 !important;
                column-gap: 0 !important;
                display: block !important;
            }

            /* Prevent splitting of gallery items */
            .gallery-item {
                page-break-inside: avoid !important;
                break-inside: avoid !important;
                page-break-before: auto;
                page-break-after: auto;
                margin-bottom: 15px !important;
                display: block !important;
                box-shadow: none !important;
                border: none !important;
                width: 100% !important;
            }

            /* Optimize images for print */
            .gallery-item img {
                max-width: 100% !important;
                max-height: 45vh !important;
                height: auto !important;
                object-fit: contain !important;
                page-break-inside: avoid !important;
                break-inside: avoid !important;
                border-bottom: none !important;
                display: block !important;
            }

            /* Prevent content splitting */
            .content, .description, .metadata, .keywords, .recognized-faces, .detected-objects, .scene-classification {
                page-break-inside: avoid !important;
                break-inside: avoid !important;
            }

            /* Hide interactive and non-essential elements */
            .actions, .copy-path-btn, .view-original, .edit-btn, .delete-btn, .sentinel {
                display: none !important;
            }

            /* Remove hover effects */
            .gallery-item:hover {
                transform: none !important;
                box-shadow: none !important;
                border: none !important;
            }

            /* Hide overlays */
            .face-overlay, .object-overlay {
                display: none !important;
            }

            /* Style tags for print */
            .face-name-tag, .object-name-tag, .scene-name-tag {
                background-color: #f8f9fa !important;
                color: #495057 !important;
                padding: 2px 6px !important;
                border-radius: 10px !important;
                font-size: 10px !important;
                border: 1px solid #dee2e6 !important;
                font-weight: normal !important;
                cursor: auto !important;
                -webkit-print-color-adjust: exact;
                color-adjust: exact;
            }

            /* Optimize text */
            .short-description, .long-description {
                page-break-inside: avoid !important;
                color: #333 !important;
            }

            /* Ensure white background */
            html, body, #bg {
                background-color: white !important;
            }

            /* Text color for readability */
            .header h1 {
                color: #333 !important;
            }

            .header p {
                color: #666 !important;
            }

            /* Remove any overflow constraints */
            * {
                overflow: visible !important;
            }
        }
        </style>
    </head>
    <body>
        <div id="bg">
            <div class="header">
                <h1 id="gallery-title">Family Photo Gallery</h1>
                <p id="gallery-description">Hover over images to see face recognition data</p>
            </div>
            <div class="gallery-container">
                <div id="gallery" class="masonry">
                    <div class="loading">Loading images...</div>
                </div>
                <div id="sentinel" class="sentinel"></div>
            </div>
        </div>
        <script>
        let imageGallery;
        let mydata = {
            images: JSON.parse("[]"),
            title: "Photo Gallery",
            description: "Hover over images to see face recognition data",
            actions: [],
            canEdit: false,
            canDelete: false
        };

        function parsePsObject(str) {
            if (!str || typeof str !== 'string' || !str.startsWith('@{')) return null;
            const content = str.substring(2, str.length - 1);
            const obj = {};
            const parts = content.split(';');
            parts.forEach(part => {
                const eqIndex = part.indexOf('=');
                if (eqIndex > -1) {
                    const key = part.substring(0, eqIndex).trim();
                    const value = part.substring(eqIndex + 1).trim();
                    obj[key] = isNaN(value) ? value : parseFloat(value);
                }
            });
            return obj;
        }

        function parsePsObjectArray(str) {
            if (Array.isArray(str)) return str;
            if (!str || typeof str !== 'string') return [];

            const objects = [];
            const regex = /@\{.*?\}/g;
            const matches = str.match(regex);

            if (matches) {
                matches.forEach(match => {
                    const obj = parsePsObject(match);
                    if (obj) {
                        objects.push(obj);
                    }
                });
            }
            return objects;
        }

        // Mock API to simulate fetching images
        async function fetchImages(page, pageSize) {
            await new Promise(resolve => setTimeout(resolve, 1000));
            const images = [];
            const startIndex = (page - 1) * pageSize;
            for (let i = Math.min(mydata.images, startIndex); i < Math.min(mydata.images.length, startIndex + pageSize); i++) {

                images.push(mydata.images[i]);

            }
            return images;
        }
        // Mock API to fetch all images for print
        async function fetchAllImages(maxImages = 50) {

            return mydata.images.slice(0, maxImages);
        }

        class ImageGallery {
            constructor(mydata) {

                this.images = [];
                this.galleryElement = document.getElementById('gallery');
                this.sentinel = document.getElementById('sentinel');
                this.page = 1;
                this.pageSize = 20;  // Increased from 10 to 20 for smoother scrolling
                this.isLoading = false;
                this.hasMore = true;
                this.isPrinting = false;
                this.init();
            }

            async init() {
                if (typeof mydata !== 'undefined' && mydata.images && mydata.images.length > 0) {
                    // Use provided image data
                    this.images = mydata.images;
                    this.hasMore = false; // Disable infinite scroll for provided data
                    this.renderGallery();
                } else {
                    // Use mock data for testing
                    await this.loadImages();
                }

                if (typeof mydata !== 'undefined') {
                    if (mydata.title) {
                        document.getElementById('gallery-title').textContent = mydata.title;
                        document.title = mydata.title;
                    }
                    if (mydata.description) {
                        document.getElementById('gallery-description').textContent = mydata.description;
                    }
                }

                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        this.repositionAllOverlays();
                    }, 250);
                });

                // Handle print events
                window.addEventListener('beforeprint', () => this.handleBeforePrint());
                window.addEventListener('afterprint', () => this.handleAfterPrint());

                this.setupIntersectionObserver();
            }

            setupIntersectionObserver() {
                this.observer = new IntersectionObserver(
                    entries => {
                        if (entries[0].isIntersecting && !this.isLoading && this.hasMore && !this.isPrinting) {
                            this.loadImages();
                        }
                    },
                    {
                        root: null,
                        rootMargin: '1200px',  // Load content when sentinel is 1200px away from viewport
                        threshold: 0.1
                    }
                );
                this.observer.observe(this.sentinel);
            }

            async handleBeforePrint() {
                this.isPrinting = true;
                this.observer.disconnect(); // Disable infinite scroll
                this.isLoading = true;
                this.showLoading();

                try {
                    // Fetch all images (up to a reasonable limit, e.g., 50)
                    const allImages = await fetchAllImages(50);
                    this.images = allImages;
                    this.hasMore = false;
                    this.renderGallery();
                } catch (error) {
                    console.error('Error loading images for print:', error);
                    this.showError();
                } finally {
                    this.isLoading = false;
                    this.hideLoading();
                }
            }

            handleAfterPrint() {
                this.isPrinting = false;
                this.images = []; // Reset images
                this.page = 1;
                this.hasMore = true;
                this.loadImages(); // Reload initial set
                this.setupIntersectionObserver(); // Re-enable infinite scroll
            }

            async loadImages() {
                if (this.isLoading || !this.hasMore || this.isPrinting) return;
                this.isLoading = true;
                this.showLoading();

                try {
                    const newImages = await fetchImages(this.page, this.pageSize);
                    if (newImages.length === 0) {
                        this.hasMore = false;
                        this.hideLoading();
                        return;
                    }

                    this.images = [...this.images, ...newImages];
                    this.page += 1;

                    if (this.images.length === newImages.length) {
                        this.renderGallery();
                    } else {
                        newImages.forEach((image, index) => {
                            const globalIndex = this.images.length - newImages.length + index;
                            const galleryItem = this.createGalleryItem(image, globalIndex);
                            this.galleryElement.appendChild(galleryItem);
                        });
                    }

                    if (newImages.length < this.pageSize) {
                        this.hasMore = false;
                    }
                } catch (error) {
                    console.error('Error loading images:', error);
                    this.showError();
                } finally {
                    this.isLoading = false;
                    this.hideLoading();
                }
            }

            showLoading() {
                this.sentinel.classList.add('loading');
                this.sentinel.innerHTML = 'Loading more images...';
            }

            hideLoading() {
                this.sentinel.classList.remove('loading');
                this.sentinel.innerHTML = '';
            }

            showError() {
                this.sentinel.innerHTML = '<div class="no-images"><h3>Error loading images</h3></div>';
            }

            renderGallery() {
                if (this.images.length === 0) {
                    this.showNoImagesMessage();
                    return;
                }

                this.galleryElement.innerHTML = '';

                this.images.forEach((image, index) => {
                    const galleryItem = this.createGalleryItem(image, index);
                    this.galleryElement.appendChild(galleryItem);
                });
            }

            createGalleryItem(image, index) {
                const item = document.createElement('div');
                item.className = 'gallery-item';
                item.id = `image-${index}`;

                let keywords = [];
                if (typeof image.keywords === 'string' && image.keywords.startsWith('[')) {
                    try {
                        keywords = JSON.parse(image.keywords);
                    } catch (e) {
                        keywords = [];
                    }
                } else if (Array.isArray(image.keywords)) {
                    keywords = image.keywords;
                }

                const faces = (typeof image.people?.faces === 'string') ? [image.people.faces] : (Array.isArray(image.people?.faces) ? image.people.faces : []);
                const faceCount = image.people?.count || 0;

                console.log('Processing image:', image.path);
                console.log('People data:', image.people);
                console.log('Faces array:', faces);
                console.log('Face count:', faceCount);                const objects = Array.isArray(image.objects?.objects) ? image.objects.objects : [];
                const objectCount = image.objects?.count || 0;
                const objectCounts = (typeof image.objects?.object_counts === 'string') ? (parsePsObject(image.objects.object_counts) || {}) : (image.objects?.object_counts || {});                // Handle scene classification data
                const scene = image.scenes?.scene || 'unknown';
                const sceneConfidence = image.scenes?.confidence || 0;
                const sceneConfidencePercentage = Math.round((sceneConfidence * 100)) || 0;
                const sceneSuccess = image.scenes?.success || false;

                item.innerHTML = `
                    <div class="image-container">
                        <img src="${this.escapeHtml(image.path)}"
                             alt="${this.escapeHtml(image.description?.short_description || 'Image')}"
                             loading="lazy"
                             onload="imageGallery.onImageLoad(this, ${index})"
                             onerror="imageGallery.onImageError(this)" />
                    </div>
                    <div class="content">
                        <div class="description">
                            <div class="short-description">${this.escapeHtml(image.description?.short_description || 'No description')}</div>
                            <div class="long-description">${this.escapeHtml(image.description?.long_description || '')}</div>
                        </div>                        <div class="metadata">
                            ${faceCount > 0 ? `<span class="metadata-item people">${faceCount} ${faceCount === 1 ? 'person' : 'people'}</span>` : ''}
                            ${faces.length > 0 ? `<span class="metadata-item faces">${faces.length} ${faces.length === 1 ? 'face' : 'faces'} recognized</span>` : ''}
                            ${objectCount > 0 ? `<span class="metadata-item objects">${objectCount} ${objectCount === 1 ? 'object' : 'objects'} detected</span>` : ''}
                            ${sceneSuccess && scene !== 'unknown' ? `<span class="metadata-item scene">Scene: ${scene.replace(/_/g, ' ')} (${sceneConfidencePercentage}%)</span>` : ''}
                            <span class="metadata-item">${image.description?.picture_type || 'Photo'}</span>
                            <span class="metadata-item">${image.description?.style_type || 'Unknown style'}</span>
                        </div>
                        ${keywords.length > 0 ? `
                        <div class="keywords">
                            <div class="keywords-label">Keywords:</div>
                            ${keywords.map(keyword => `<span class="keyword-tag">${this.escapeHtml(keyword)}</span>`).join('')}
                        </div>
                        ` : ''}
                        ${faces.length > 0 ? `
                        <div class="recognized-faces">
                            <div class="faces-label">Recognized faces:</div>
                            ${faces.map((faceName, faceIndex) => {
                                const clickHandler = (typeof mydata !== 'undefined' && mydata.canEdit)
                                    ? ` onclick=\"imageGallery.editFace(${index}, '${this.escapeHtml(faceName)}', ${faceIndex})\" class=\"face-name-tag clickable\"`
                                    : ' class="face-name-tag"';
                                return `<button type="button"${clickHandler}>${this.escapeHtml(faceName)}</button>`;
                            }).join('')}
                        </div>                        ` : ''}
                        ${Object.keys(objectCounts).length > 0 ? `
                        <div class="detected-objects">
                            <div class="objects-label">Detected objects:</div>
                            ${Object.entries(objectCounts).map(([objectName, count]) => {
                                const clickHandler = (typeof mydata !== 'undefined' && mydata.canEdit)
                                    ? ` onclick="imageGallery.editObject(${index}, '${this.escapeHtml(objectName)}', ${count})" class="object-name-tag clickable"`
                                    : ' class="object-name-tag"';
                                return `<span${clickHandler}>${this.escapeHtml(objectName)} (${count})</span>`;
                            }).join('')}
                        </div>
                        ` : ''}
                        ${sceneSuccess && scene !== 'unknown' ? `
                        <div class="scene-classification">
                            <div class="scene-label">Scene classification:</div>
                            ${(() => {
                                const clickHandler = (typeof mydata !== 'undefined' && mydata.canEdit)
                                    ? ` onclick="imageGallery.editScene(${index}, '${this.escapeHtml(scene)}', ${sceneConfidencePercentage})" class="scene-name-tag clickable"`
                                    : ' class="scene-name-tag"';
                                return `<span${clickHandler}>${this.escapeHtml(scene.replace(/_/g, ' '))} (${sceneConfidencePercentage}%)</span>`;
                            })()}
                        </div>
                        ` : ''}
                        <div class="actions">
                            <button class="copy-path-btn" onclick="imageGallery.copyPath(${index})">Copy Path</button>
                            <a href="${this.escapeHtml(image.path)}" target="_blank" class="view-original">View Original</a>
                            ${(typeof mydata !== 'undefined' && mydata.canEdit) ? `<button class="edit-btn" onclick="imageGallery.editImage(${index})">Edit</button>` : ''}
                            ${(typeof mydata !== 'undefined' && mydata.canDelete) ? `<button class="delete-btn" onclick="imageGallery.deleteImage(${index})">Delete</button>` : ''}
                        </div>
                    </div>
                `;

                return item;
            }

            onImageLoad(imgElement, imageIndex) {
                console.log('Image loaded:', imageIndex, 'Adding face and object overlays...');
                this.addFaceOverlays(imgElement, imageIndex);
                this.addObjectOverlays(imgElement, imageIndex);
            }

            onImageError(imgElement) {
                const container = imgElement.closest('.gallery-item');
                imgElement.style.display = 'none';

                const errorDiv = document.createElement('div');
                errorDiv.className = 'image-error';
                errorDiv.innerHTML = `
                    <div style="padding: 40px; text-align: center; color: #e74c3c; background: #fff5f5;">
                        <div style="font-size: 24px; margin-bottom: 8px;">ðŸ“·</div>
                        <div style="font-size: 12px;">Image not found</div>
                    </div>
                `;
                imgElement.parentNode.appendChild(errorDiv);
            }

            addFaceOverlays(imgElement, imageIndex) {
                const image = this.images[imageIndex];
                console.log('addFaceOverlays called for image:', imageIndex, 'people data:', image.people);

                const facePredictions = parsePsObjectArray(image.people?.predictions);
                const faces = (typeof image.people?.faces === 'string') ? image.people.faces.split(' ').filter(Boolean) : (Array.isArray(image.people?.faces) ? image.people.faces : []);
                const objectPredictions = parsePsObjectArray(image.objects?.predictions);

                console.log('Face predictions found:', facePredictions);
                console.log('Faces found:', faces);
                console.log('Object predictions found:', objectPredictions);

                const personObjects = objectPredictions.filter(pred => pred.label === 'person');
                console.log('Person objects found:', personObjects);

                if (facePredictions.length === 0 && faces.length === 0 && personObjects.length === 0) {
                    console.log('No faces, predictions, or person objects to overlay');
                    return;
                }

                const container = imgElement.parentElement;
                const displayWidth = imgElement.clientWidth;
                const displayHeight = imgElement.clientHeight;
                const originalWidth = imgElement.naturalWidth;
                const originalHeight = imgElement.naturalHeight;

                console.log('Display dimensions:', displayWidth, 'x', displayHeight);
                console.log('Original dimensions:', originalWidth, 'x', originalHeight);

                const mergedOverlays = this.createMergedOverlays(facePredictions, personObjects, faces);

                mergedOverlays.forEach((overlayData, index) => {
                    const overlay = document.createElement('div');
                    overlay.className = 'face-overlay';

                    const leftRatio = overlayData.x_min / originalWidth;
                    const topRatio = overlayData.y_min / originalHeight;
                    const widthRatio = (overlayData.x_max - overlayData.x_min) / originalWidth;
                    const heightRatio = (overlayData.y_max - overlayData.y_min) / originalHeight;

                    const left = leftRatio * displayWidth;
                    const top = topRatio * displayHeight;
                    const width = widthRatio * displayWidth;
                    const height = heightRatio * displayHeight;

                    overlay.style.left = left + 'px';
                    overlay.style.top = top + 'px';
                    overlay.style.width = width + 'px';
                    overlay.style.height = height + 'px';

                    overlay.setAttribute('data-bounds', JSON.stringify({
                        x_min: overlayData.x_min,
                        y_min: overlayData.y_min,
                        x_max: overlayData.x_max,
                        y_max: overlayData.y_max,
                        confidence: overlayData.confidence
                    }));

                    const clickHandler = overlayData.type === 'face'
                        ? `imageGallery.editFace(${imageIndex}, '${this.escapeHtml(overlayData.label)}', ${index})`
                        : `imageGallery.editObject(${imageIndex}, '${this.escapeHtml(overlayData.label)}', ${index})`;

                    const labelClass = overlayData.type === 'face' ? 'face-label' : 'object-label';
                    overlay.innerHTML = `<span class="${labelClass} clickable" onclick="${clickHandler}">${this.escapeHtml(overlayData.label)}<br>confidence: ${Math.round(overlayData.confidence * 100)}%</span>`;
                    container.appendChild(overlay);
                });

                if (mergedOverlays.length === 0 && faces.length > 0) {
                    faces.forEach((faceName, index) => {
                        const overlay = document.createElement('div');
                        overlay.className = 'face-overlay';

                        const facePositions = this.generateFacePositions(faces.length, displayWidth, displayHeight);
                        const position = facePositions[index];

                        overlay.style.left = position.left + 'px';
                        overlay.style.top = position.top + 'px';
                        overlay.style.width = position.width + 'px';
                        overlay.style.height = position.height + 'px';

                        overlay.innerHTML = `<span class="face-label">${this.escapeHtml(faceName)}<br>recognized</span>`;
                        container.appendChild(overlay);
                    });
                }
            }

            createMergedOverlays(facePredictions, personObjects, faces) {
                const mergedOverlays = [];
                const usedPersonIndices = new Set();

                facePredictions.forEach((facePred, faceIndex) => {
                    let faceName = 'Unknown';
                    if (facePred.userid) {
                        faceName = facePred.userid.replace(/_\d+$/, '');
                    } else if (faces && faces.length > faceIndex && faces[faceIndex] && faces[faceIndex].trim() !== '') {
                        faceName = faces[faceIndex].trim();
                    } else if (faces && faces.length > 0) {
                        for (let i = 0; i < faces.length; i++) {
                            if (faces[i] && faces[i].trim() !== '') {
                                faceName = faces[i].trim();
                                break;
                            }
                        }
                    }

                    mergedOverlays.push({
                        x_min: facePred.x_min,
                        y_min: facePred.y_min,
                        x_max: facePred.x_max,
                        y_max: facePred.y_max,
                        confidence: facePred.confidence,
                        label: faceName,
                        type: 'face'
                    });

                    personObjects.forEach((personObj, personIndex) => {
                        if (this.boundingBoxesOverlap(facePred, personObj)) {
                            usedPersonIndices.add(personIndex);
                        }
                    });
                });

                personObjects.forEach((personObj, personIndex) => {
                    if (!usedPersonIndices.has(personIndex)) {
                        mergedOverlays.push({
                            x_min: personObj.x_min,
                            y_min: personObj.y_min,
                            x_max: personObj.x_max,
                            y_max: personObj.y_max,
                            confidence: personObj.confidence,
                            label: 'Person',
                            type: 'person'
                        });
                    }
                });

                return mergedOverlays;
            }

            boundingBoxesOverlap(box1, box2) {
                const overlapX = Math.max(0, Math.min(box1.x_max, box2.x_max) - Math.max(box1.x_min, box2.x_min));
                const overlapY = Math.max(0, Math.min(box1.y_max, box2.y_max) - Math.max(box1.y_min, box2.y_min));
                const overlapArea = overlapX * overlapY;

                const box1Area = (box1.x_max - box1.x_min) * (box1.y_max - box1.y_min);
                const box2Area = (box2.x_max - box2.x_min) * (box2.y_max - box2.y_min);
                const smallerArea = Math.min(box1Area, box2Area);

                return overlapArea > (smallerArea * 0.5);
            }

            generateFacePositions(faceCount, imgWidth, imgHeight) {
                const positions = [];
                const faceSize = Math.min(imgWidth, imgHeight) * 0.15;
                const minFaceSize = 60;
                const maxFaceSize = 120;

                const actualFaceSize = Math.max(minFaceSize, Math.min(maxFaceSize, faceSize));

                const faceAreas = [
                    { x: 0.2, y: 0.15, w: 0.25, h: 0.4 },
                    { x: 0.4, y: 0.1, w: 0.2, h: 0.35 },
                    { x: 0.55, y: 0.15, w: 0.25, h: 0.4 },
                    { x: 0.15, y: 0.4, w: 0.3, h: 0.35 },
                    { x: 0.55, y: 0.4, w: 0.3, h: 0.35 },
                    { x: 0.35, y: 0.45, w: 0.6, h: 0.35 }
                ];

                for (let i = 0; i < faceCount; i++) {
                    const area = faceAreas[i % faceAreas.length];
                    const randomX = Math.random() * 0.5;
                    const randomY = Math.random() * 0.5;

                    const left = (area.x + randomX * area.w) * imgWidth;
                    const top = (area.y + randomY * area.h) * imgHeight;

                    const maxLeft = imgWidth - actualFaceSize;
                    const maxTop = imgHeight - actualFaceSize;

                    positions.push({
                        left: Math.max(0, Math.min(maxLeft, left)),
                        top: Math.max(0, Math.min(maxTop, top)),
                        width: actualFaceSize,
                        height: actualFaceSize
                    });
                }

                return positions;
            }

            addObjectOverlays(imgElement, imageIndex) {
                const image = this.images[imageIndex];
                console.log('addObjectOverlays called for image:', imageIndex, 'objects data:', image.objects);

                const predictions = parsePsObjectArray(image.objects?.predictions);
                const facePredictions = parsePsObjectArray(image.people?.predictions);

                console.log('Object predictions found:', predictions);

                if (predictions.length === 0) {
                    console.log('No object predictions to overlay');
                    return;
                }

                const filteredPredictions = predictions.filter(objPred => {
                    if (objPred.label !== 'person') {
                        return true;
                    }

                    const hasOverlappingFace = facePredictions.some(facePred =>
                        this.boundingBoxesOverlap(objPred, facePred)
                    );

                    return !hasOverlappingFace;
                });

                console.log('Filtered object predictions (excluding person objects with faces):', filteredPredictions);

                const container = imgElement.parentElement;
                const displayWidth = imgElement.clientWidth;
                const displayHeight = imgElement.clientHeight;
                const originalWidth = imgElement.naturalWidth;
                const originalHeight = imgElement.naturalHeight;

                console.log('Display dimensions:', displayWidth, 'x', displayHeight);
                console.log('Original dimensions:', originalWidth, 'x', originalHeight);

                filteredPredictions.forEach((prediction, index) => {
                    const overlay = document.createElement('div');
                    overlay.className = 'object-overlay';

                    const leftRatio = prediction.x_min / originalWidth;
                    const topRatio = prediction.y_min / originalHeight;
                    const widthRatio = (prediction.x_max - prediction.x_min) / originalWidth;
                    const heightRatio = (prediction.y_max - prediction.y_min) / originalHeight;

                    const left = leftRatio * displayWidth;
                    const top = topRatio * displayHeight;
                    const width = widthRatio * displayWidth;
                    const height = heightRatio * displayHeight;

                    overlay.style.left = left + 'px';
                    overlay.style.top = top + 'px';
                    overlay.style.width = width + 'px';
                    overlay.style.height = height + 'px';

                    overlay.setAttribute('data-bounds', JSON.stringify({
                        x_min: prediction.x_min,
                        y_min: prediction.y_min,
                        x_max: prediction.x_max,
                        y_max: prediction.y_max,
                        confidence: prediction.confidence,
                        label: prediction.label
                    }));

                    const label = document.createElement('div');
                    label.className = 'object-label';
                    const confidence = (prediction.confidence * 100).toFixed(1);
                    label.textContent = `${prediction.label} (${confidence}%)`;
                    overlay.appendChild(label);

                    container.appendChild(overlay);
                    console.log(`Added object overlay for ${prediction.label} at (${left.toFixed(1)}, ${top.toFixed(1)}) with size ${width.toFixed(1)}x${height.toFixed(1)}`);
                });
            }            copyPath(index) {
                const image = this.images[index];
                const path = `"${image.originalPath || image.path}"`;

                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(path).then(() => {
                        this.showCopyFeedback(index, true);
                    }).catch(err => {
                        console.error('Failed to copy:', err);
                        this.fallbackCopy(path, index);
                    });
                } else {
                    this.fallbackCopy(path, index);
                }
            }            editImage(index) {
                if (typeof mydata === 'undefined' || !mydata.canEdit) {
                    console.warn('Edit action not allowed - canEdit is false or undefined');
                    return;
                }

                const image = this.images[index];
                const editAction = {
                    action: "edit",
                    path: image.originalPath || image.path
                };

                mydata.actions.push(editAction);
                this.showEditFeedback(index);
            }

            showEditFeedback(index) {
                const button = document.querySelector(`#image-${index} .edit-btn`);
                if (!button) return;

                const originalText = button.textContent;
                button.textContent = 'Added to Queue';
                button.style.backgroundColor = '#f39c12';

                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.backgroundColor = '';
                }, 1500);
            }

            editFace(imageIndex, faceName, faceIndex) {
                if (typeof mydata === 'undefined' || !mydata.canEdit) {
                    return;
                }

                const image = this.images[imageIndex];
                const facePredictions = parsePsObjectArray(image.people?.predictions);
                let boundingBox = null;

                const matchingPrediction = facePredictions.find(pred => {
                    const predName = pred.userid ? pred.userid.replace(/_\d+$/, '') : '';
                    return predName === faceName;
                });

                if (matchingPrediction) {
                    boundingBox = {
                        x_min: matchingPrediction.x_min,
                        y_min: matchingPrediction.y_min,
                        x_max: matchingPrediction.x_max,
                        y_max: matchingPrediction.y_max,
                        width: matchingPrediction.x_max - matchingPrediction.x_min,
                        height: matchingPrediction.y_max - matchingPrediction.y_min,
                        confidence: matchingPrediction.confidence
                    };
                }

                const editAction = {
                    action: "edit",
                    path: image.path,
                    faceName: faceName,
                    faceIndex: faceIndex,
                    boundingBox: boundingBox,
                    timestamp: new Date().toISOString()
                };

                mydata.actions.push(editAction);
                console.log('Added face edit action:', editAction);
                this.showTagClickFeedback(imageIndex, 'face', faceName);
            }

            editObject(imageIndex, objectName, count) {
                if (typeof mydata === 'undefined' || !mydata.canEdit) {
                    return;
                }

                const image = this.images[imageIndex];
                const objectPredictions = parsePsObjectArray(image.objects?.predictions);
                const matchingObjects = objectPredictions.filter(pred => pred.label === objectName);

                const boundingBoxes = matchingObjects.map(pred => ({
                    x_min: pred.x_min,
                    y_min: pred.y_min,
                    x_max: pred.x_max,
                    y_max: pred.y_max,
                    width: pred.x_max - pred.x_min,
                    height: pred.y_max - pred.y_min,
                    confidence: pred.confidence
                }));

                const editAction = {
                    action: "edit",
                    path: image.path,
                    objectName: objectName,
                    count: count,
                    boundingBox: boundingBoxes.length > 0 ? boundingBoxes[0] : null,
                    timestamp: new Date().toISOString()
                };

                mydata.actions.push(editAction);
                console.log('Added object edit action:', editAction);
                this.showTagClickFeedback(imageIndex, 'object', objectName);
            }

            showTagClickFeedback(imageIndex, type, name) {
                const selector = type === 'face'
                    ? `#image-${imageIndex} .face-name-tag.clickable`
                    : `#image-${imageIndex} .object-name-tag.clickable`;

                const tags = document.querySelectorAll(selector);

                tags.forEach(tag => {
                    if (tag.textContent.includes(name)) {
                        const originalBg = tag.style.backgroundColor;
                        const originalText = tag.textContent;

                        tag.style.backgroundColor = '#28a745';
                        tag.style.color = 'white';
                        tag.textContent = 'Edited!';

                        setTimeout(() => {
                            tag.style.backgroundColor = originalBg;
                            tag.style.color = '';
                            tag.textContent = originalText;
                        }, 1500);
                    }
                });
            }            deleteImage(index) {
                const image = this.images[index];
                const deleteAction = {
                    action: "delete",
                    path: image.originalPath || image.path
                };

                mydata.actions.push(deleteAction);
                const imageTile = document.getElementById(`image-${index}`);
                if (imageTile) {
                    imageTile.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                    imageTile.style.opacity = '0';
                    imageTile.style.transform = 'scale(0.95)';

                    setTimeout(() => {
                        imageTile.remove();
                    }, 300);
                }

                this.showDeleteFeedback(index);
            }

            showDeleteFeedback(index) {
                const button = document.querySelector(`#image-${index} .delete-btn`);
                if (!button) return;

                const originalText = button.textContent;
                button.textContent = 'Deleting...';
                button.style.backgroundColor = '#e74c3c';
                button.disabled = true;
            }

            fallbackCopy(text, index) {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();

                try {
                    const result = document.execCommand('copy');
                    this.showCopyFeedback(index, result);
                } catch (err) {
                    console.error('Fallback copy failed:', err);
                    this.showCopyFeedback(index, false);
                }

                document.body.removeChild(textArea);
            }

            showCopyFeedback(index, success) {
                const button = document.querySelector(`#image-${index} .copy-path-btn`);
                if (!button) return;

                const originalText = button.textContent;
                button.textContent = success ? 'Copied!' : 'Failed';
                button.style.backgroundColor = success ? '#27ae60' : '#e74c3c';

                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.backgroundColor = '';
                }, 2000);
            }

            showNoImagesMessage() {
                this.galleryElement.innerHTML = `
                    <div class="no-images">
                        <h3>No Images Found</h3>
                    </div>
                `;
            }

            escapeHtml(text) {
                if (!text) return '';
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            repositionAllOverlays() {
                this.images.forEach((image, index) => {
                    const imgElement = document.querySelector(`#image-${index} img`);
                    if (imgElement && imgElement.complete && imgElement.naturalWidth > 0) {
                        const existingFaceOverlays = document.querySelectorAll(`#image-${index} .face-overlay`);
                        existingFaceOverlays.forEach(overlay => overlay.remove());

                        const existingObjectOverlays = document.querySelectorAll(`#image-${index} .object-overlay`);
                        existingObjectOverlays.forEach(overlay => overlay.remove());

                        this.addFaceOverlays(imgElement, index);
                        this.addObjectOverlays(imgElement, index);
                    }
                });
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            imageGallery = new ImageGallery(mydata);
        });

        window.getActions = function () {
            let results = [...mydata.actions];
            mydata.actions = [];
            return results;
        };
        </script>
    </body>
</html>
